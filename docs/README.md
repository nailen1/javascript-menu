# 🍚 점심 메뉴 추천

## 파일 목록과 메소드 설명

### `App.js`

점심 메뉴 추천 앱을 실행하는 클래스. 실행은 `play` 메소드를 이용한다.

### `Coach.js`

코치의 1명에 해당하는 클래스. 프로그램 동작 과정 중 저장되는 정보를 모두 명시적으로 담고 있음.

- 코치의 이름을 입력받아 생성되며, 동시에 이름의 유효성을 검증한다(`isValidName`).
- 코치가 못 먹는 음식을 입력받고, 각 음식을 카테고리에 알맞게 카테고리명: 메뉴 배열 형식의 객체로 저장한다. (메소드 `setDislikes`, 속성 `this.disLikes`) 아래는 저장 예시
  `{ '일식': ['우동', '규동'], '한식': [], '중식': [], '아시안': [], 양식: []}`
- 입력 받은 음식이 유효한 음식 이름인지를 검증한다. 전체 메뉴를 카테고리별 반복문으로 추출하여 한 덩어리의 문자열로 저장 후 문자 포함 여부를 확인하여 검증함. (메소드 `isValidMenu`)
- 코치의 this.dislikes 정보를 이용하여, 코치가 먹을 수 있는 메뉴만을 객체로 저장한다. (메소드 `setLikes`, 속성 `this.likes`). `this.likes`는 private field화 가능하지만 섞는 과정 전후의 투명성 담보위해 private화 하지 않음.
- 코치의 this.likes 정보를 이용하여, 코치가 먹을 수 있는 메뉴 순서를 무작위로 섞는다. (메소드 메소드 `shuffleLikes`, 속성 `this.shuffled`)

클래스 Coach로 만들어진 객체 콘솔 출력 예시 (출력해서 저장된 각종 데이터 확인 요망)

```

  Coach {
    dislikes: { '일식': [Array], '한식': [], '중식': [], '아시안': [], '양식': [] },
    likes: {
      '일식': [Array],
      '한식': [Array],
      '중식': [Array],
      '아시안': [Array],
      '양식': [Array]
    },
    shuffled: {
      '일식': [Array],
      '한식': [Array],
      '중식': [Array],
      '아시안': [Array],
      '양식': [Array]
    },
    name: '토미'
  }

```

### `Recommend.js`

클래스 Coach로부터 만들어진 코치 수명의 정보를 일부(coach.shuffled) 전달받아, 콘솔 화면 출력에 필요한 다양한 정보를 가공하는 클래스. 입력 과정에서 생성되는 중간 정보 역시 명시적으로 저장함.

- 코치 이름 목록을 입력 받아 생성됨. 이와 동시에 코치의 수 우효성을 검증함. (메소드 `isValidMembers`)
- 음식 카테고리 인덱스로 사용될 1~5 사이의 난수 배열을 생성한다. 단, 같은 수는 2번까지만 중복을 허용함. (메소드 ` setIndexArr`)
- 난수 배열로부터 한주 각 요일에 먹을 음식 카테고리 목록을 얻음. (메소드 `setWeekCategory`)
- coach.shuffled에 담긴 정보, 그리고 앞서 생성된 난수 배열로부터 한명의 코치가, 한주 각 요일에 먹을 음식의 목록을 얻음. 코치의 수만큼, 각 코치 이름과 음식 목록 객체가 배열로 저장됨. (메소드 `setCoachMenus(coach)` 속성 `this.coachMenus`)
  저장 예시:
  ```
  [
    {name: '토미', menu: ['쌈밥', '김치찌개', '미소시루', '짜장면', '팟타이']},
    {name: '포코', menu: ['된장찌개', '불고기`, '하이라이스', '탕수육', '나시고렝']}
  ]
  ```
- 코치의 수만큼 못 먹는 메뉴 입력을 반복하기 위해 상태 step을 관리 메소드 (`addStep` 속성 `this.step`)

클래스 Recommend로 만들어진 객체 콘솔 출력 예시 (출력해서 저장된 각종 데이터 확인 요망)

```
Recommend {
  step: 2,
  weekCategory: [ '일식', '한식', '한식', '일식', '중식' ],
  coachMenus: [ { name: '포코', menu: [Array] }, { name: '제임스', menu: [Array] } ],
  coachNames: [ '포코', '제임스' ],
  numberOfCoaches: 2
}
```

### `InputView.js`

점심 메뉴 추천 앱 작동시 입력과 입력 후 절차에 필요한 메소드들로 구성된 객체. 크게 입력을 받는 read... 메소드들과 입력받은 후 실행 또는 예외상황 에러 처리 try{} catch(e){} 구문으로 이루어진 try... 메소드로 구성됨

### `OutputView.js`

점심 메뉴 추천 앱 작동시 결과 콘솔 출력에 필요한 메소드들로 구성된 객체. 출력 결과의 가급적 하드코딩을 최대한 지양하도록 앞선 `Recommend.js` 클래스로부터 저장된 객체의 정보를 변수로 활용하였음. (`printResult(recommend)` 메소드 참조)

## 기능 구현 시 주안점

- 각 클래스로부터 생성되는 객체는 메뉴 추천 과정에서 발생하는 데이터나 상태를 명시적으로 저장함
- 미션에 주어진 메뉴 목록의 형태를 그대로 두고, 메뉴 목록 하나만을 상수로 두어 부차적으로 발생할 수 있는 상수들은 하드코딩 없이 알고리즘으로 구현

=========== 만약 읽어주셨다면, 정말로, 그리고 진심으로 감사합니다! =============

=========== 이하 수정전 원문 ==========

예외 상황 고려히지 않은 전체적인 기능 스케치
`App.js` > play 메소드에 작성

전체적인 입출력 흐름 구현 스케치
InputView, OutputView 스케치 작성,
readLine, print 함수 호출 시퀀스

코치 클래스에 필드 정의(이름, 못 먹는 메뉴, 먹을 수 있는 메뉴) (`Coach.js`)

못 먹는 메뉴를 입력 받아 메뉴 리스트에서 제외하는 기능 (`InputView.js` > readDislikes)

사소한 기능구현 세부사항에 집착하다 시간을 지키지 못했습니다.
못 먹는 메뉴 구현시 클래스 객체의 정보를 (시간이 여유있을 때나 스스로 코딩할 때처럼)
예를 들어,
Coach {'일식': ['규동'], '한식': ['김치찌개']},
Coach {'일식': ['규동', '우동']}
처럼 깔끔한 객채화 출력 등 사소함에 집착하다보니 정신이 팔렸던 것 같습니다.
아쉬움과 안타까움이 많이 남습니다.
